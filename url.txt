SoftwareWrap.orgGet Ready...to wrap your head around software that does more!COMING SOON: This site will launch on July 26th, just one day ahead of the presentation that will be made at https://www.meetup.com/triangletechtalks/events/294527903/on July 27th at 5pm!Tools include: executables, libraries, APIs, and all of what software developers use in creating products. The Problem: Tools available during development may have issues: the learning curve, not part of a workflow, does too much, does too little, lacks extensibility, performance, deprecation, complexity and more. Yet, it might not be possible or practical to replace tools. So, what can be done to address the above problems? The Solution: The general approach is to recognize that adding a layer of abstraction (wrapping) makes hard problems easier to solve. There are various ways to add these abstraction layers and three demos will be provided to make it easy to understand how attendees can adopt similar practices to \"do more with existing tools.\" We will have three intense demos. 15 minutes each!Do More with Existing ToolsTriangle Tech Talks - July 27 @ 5pmDemo 1: Steve Amerige Problem: Bash lacks namespace protection and Java lacks macro processing. Solution: Demonstrate a layer of abstraction around Bash that adds namespace protection, object orientation, JSON handling, and much more. The demonstration will be Java code that contains commented idioms that behave as macros that allows for Java code preprocessing prior to compilation. Demo 2: Will Allen Problem: Rust lacks the ability to define dynamic data structures. For example, defining structs from a JSON schema. Solution: The na√Øve approach to defining a data structure from a JSON schema would be to manually design a struct (often with deeply nested fields) that represents the desired schema, and instantiate it by manually reading in a JSON string. An intelligent alternative is to use Rust macros to define a data structure and the necessary methods on it. The fields and methods generated will be determined by the structure of the schema provided. This provides compile-time validation of the JSON schema itself and usage of it. It also eliminates the need to write tedious boilerplate code for every JSON schema, and enables easily changing schemas on the fly. Demo 3: Terry Herron Problem: DSLs based on yaml/json are essentially a contract. Avoid leaking underlying technology details in your DSLs to avoid problem issues. Solution: Execute custom DSLs driving abstracted third-party tools. Touching on the dynamic DSL driver, schemas, templates, serialization, and some use cases including rapid prototyping of yaml/json based DSLs. Describe some performance considerations as well.  